/*******************************************************************************
 * 在完成本作业的过程中，我从以下各位那里得到过以下方面的启发和帮助：
陈畅：关于队堆结构中堆的实现
 * 在我提交的程序中，还在对应的位置以注释形式记录了他们的具体帮助。
 *******************************************************************************
 * 我参考了以下资料：
邓俊辉老师讲义PPT274页Queap = Queue +Heap=enqueue+dequeue+getMax的方法
 * 在我提交的程序中，还在对应的位置以注释形式记录了具体的参考内容。
 *******************************************************************************
 * 我独立完成了本程序除以上方面之外的所有工作，包括分析、设计、编码、调试与测试。
 * 我清楚地知道，从以上方面获得的信息在一定程度上降低了作业难度，可能影响起评分。
 *******************************************************************************
 * 我从未抄袭或盗用过他人的程序，不管是原封不动地复制，还是经过了某些等价转换。
 * 我未曾也不会向同一课程（包括此后各届）的同学复制或公开我这份程序的代码。
 * 我编写这个程序无意于破坏或妨碍任何计算机系统的正常运转。
 * 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的作业成绩将按-100计。
 *******************************************************************************
 * 【周嘉莉】
 * 【2010010359】
 * 【2012-10-29】
 ******************************************************************************/
【算法实现】用双向链表实现了栈的功能。只能支持题目所给的四种接口。私有成员为栈底的head指针。又用链表实现了一个堆heap。用堆和栈模拟了队堆结构：该结构支持题目所给的三种操作接口，私有成员为两个栈s1,s2、s1的长度length以及堆heap的头指针*heap.
用栈s1、s2模拟了一个队列，实现了先进先出，后进后出的功能；
按照邓俊辉老师课件里第274页PPT里所讲的方法：
（1）dequeap操作时，在s1的队首元素出队的同时，只需判断当前出队的元素是否为堆heap首节点所指向的元素（说是指向，实则用存储的元素的大小进行比较来判断），如果是的话，则删除首节点；如果不是，则只需将首节点记录的节点数目--即可。
（2）enqueap操作时，在s1的队尾元素入队的同时，需要判断入队元素的大小：
如果入队元素小于之前队尾元素，则只需要插入新队尾元素，并且生成新的堆尾指针指向新队尾即可。
如果大于队尾元素，则需要在堆里向前回溯，找到某一指针里*p存的元素小于入队元素num,此时将生成新的堆指针*cur,cur存入*p指向的队里元素i和入队元素num之间的元素个数。
（3）max操作时，只需取heap的首指针指向的元素的大小即可，条件判断见具体代码。

关于堆结构：每一个节点的数据成员data有两个，为num和max；num记录着包括该节点指向的队元素在内的它之前比它小的元素个数，max记录指向的队元素的大小。因此总体的空间复杂度很小，可以认为是o(1).
【遇到的问题】在写DoubleList头文件时我先是定义了具有DataType类型数据成员data的Node,之后又写了一个有Node<DataType>*型数据成员Head、Tail的双向链表，结果在头文件里new Node的时候无法辨识DataType因此无法生成链表头文件。所以我就直接把DataType data改成了dat data，定义了main函数要用到的一个struct dat，则头文件其实不是一个模板，特此说明。
【时间复杂度分析】o(1)
【空间复杂度分析】除去栈的空间，其他空间复杂度为o(1）
