/*******************************************************************************
 * 在完成本作业的过程中，我从以下各位那里得到过以下方面的启发和帮助：

 * 在我提交的程序中，还在对应的位置以注释形式记录了他们的具体帮助。
 *******************************************************************************
 * 我参考了以下资料：
在百度知道上查到的快速排序的算法,同学的快速排序的算法
 * 在我提交的程序中，还在对应的位置以注释形式记录了具体的参考内容。
 *******************************************************************************
 * 我独立完成了本程序除以上方面之外的所有工作，包括分析、设计、编码、调试与测试。
 * 我清楚地知道，从以上方面获得的信息在一定程度上降低了作业难度，可能影响起评分。
 *******************************************************************************
 * 我从未抄袭或盗用过他人的程序，不管是原封不动地复制，还是经过了某些等价转换。
 * 我未曾也不会向同一课程（包括此后各届）的同学复制或公开我这份程序的代码。
 * 我编写这个程序无意于破坏或妨碍任何计算机系统的正常运转。
 * 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的作业成绩将按-100计。
 *******************************************************************************
 * 【周嘉莉】
 * 【2010010359】
 * 【2012-9-28】
 ******************************************************************************/
【算法分析】先用一个二维数组装载占用起始时间和降落时间，利用快速排序算法将占用起始时间按照由小到大的顺序排，降落时间跟着排。然后定义最大空闲时间lenth,先将其置为a[0][0],接着计算后面一个的占用起始时间与前一个降落时间之差，如果大于现有lenth,则更新lenth，细节问题也需考虑。
快速排序算法解释：认真研读了一番，初始时i=low-1=0,j=low=1,arraylen为右边边界值。比较a[0][j]与a[0][len]的大小，如果a[0][j]<a[0][len]，则i前进，a[0][i]与a[0][j]交换，之后j前移，如果a[0][j]>a[0][len]，则i不变，j前移，一直重复这个过程，直至j移到len的位置。
迭代的循环不变式为：
每一轮迭代的开始，对于任何数组下标k，有：
1) 如果p≤k≤i，则A[k]≤x。
2) 如果i+1≤k≤j-1，则A[k]>x。
3) 如果k=r，则A[k]=x。
【调试】换了好几种排序算法，总是超时。在网上也找了快速排序、归并排序，可是都超时，最后借鉴了同学的快排。超时问题解决后，最后一个点还是显示结果错误。调试了好久才被提醒发现数组申请的不够，居然200000都不够，太坑爹了。。。
【时间复杂度分析】o(nlogn)
