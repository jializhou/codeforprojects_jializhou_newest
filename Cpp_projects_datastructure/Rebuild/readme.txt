/*******************************************************************************
 * 在完成本作业的过程中，我从以下各位那里得到过以下方面的启发和帮助：

 * 在我提交的程序中，还在对应的位置以注释形式记录了他们的具体帮助。
 *******************************************************************************
 * 我参考了以下资料：
邓俊辉老师BinTree里的头文件及遍历的算法;
由遍历序列构造二叉树的非递归算法实现《衡水学院学报》2009年04期;

 * 在我提交的程序中，还在对应的位置以注释形式记录了具体的参考内容。
 *******************************************************************************
 * 我独立完成了本程序除以上方面之外的所有工作，包括分析、设计、编码、调试与测试。
 * 我清楚地知道，从以上方面获得的信息在一定程度上降低了作业难度，可能影响起评分。
 *******************************************************************************
 * 我从未抄袭或盗用过他人的程序，不管是原封不动地复制，还是经过了某些等价转换。
 * 我未曾也不会向同一课程（包括此后各届）的同学复制或公开我这份程序的代码。
 * 我编写这个程序无意于破坏或妨碍任何计算机系统的正常运转。
 * 我清楚地知道，以上情况均为本课程纪律所禁止，若违反，对应的作业成绩将按-100计。
 *******************************************************************************
 * 【周嘉莉】
 * 【2010010359】
 * 【2012-11-1】
 ******************************************************************************/
【算法实现】利用所给的中序、后续遍历序列生成一颗二叉树，然后通过中序遍历进行校验，如果和所给数据一致则进行先序遍历，如果在其中发现不一致则立即停止，输出-1。
生成二叉树我采用了迭代的算法，花了一天的时间考虑各种情况，发现各种bug。。。
具体算法如下：
借助了两个一维数组InD,PoD和一个BinNode<int>*类型的栈S1，将中序遍历序列和后续遍历序列放在InD和PoD中。后续序列的最后一个节点为根节点，确定root；而中序遍历序列中的最后一个节点为该二叉树最右下的节点J，在存放中序序列的数组InD中找到节点J，沿着二叉树的后续序列从后向前生成根节点的右孩子以及该节点的右孩子，直至找到J,置其右孩子的指针域为空，左孩子的确定分情况：如果其在中序序列中的前一个节点是它的parent节点，则说明它没有左孩子；否则，说明有左孩子，左孩子即为后续序列里扫描到的下一个节点。
中序遍历算法和先序遍历算法均采用邓俊辉老师所给代码。
【时间复杂度分析】o(n): 基本实现用了while循环嵌套，内层第一个while循环每循环一次，i的值减1，内层的第二个while循环每循环一次，j的值减1，外层和内层两个while循环次数之和为2n，故算法时间复杂度为2n.
【空间复杂度分析】o(n)：即栈所用空间
